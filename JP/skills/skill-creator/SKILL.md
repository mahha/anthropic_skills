---
name: skill-creator
description: 効果的なスキルを作成するためのガイド。ユーザーが専門知識、ワークフロー、またはツール統合でClaudeの機能を拡張する新しいスキル（または既存のスキルを更新）を作成したいときに使用します。
license: 完全な条件はLICENSE.txtに記載されています
---

# スキルクリエイター

このスキルは、効果的なスキルを作成するためのガイダンスを提供します。

## スキルについて

スキルは、専門知識、ワークフロー、ツールを提供することでClaudeの機能を拡張するモジュール式の自己完結型パッケージです。特定のドメインやタスクの「オンボーディングガイド」として考えてください—これらはClaudeを汎用エージェントから、モデルが完全に所有できない手続き的知識を備えた専門エージェントに変換します。

### スキルが提供するもの

1. 専門的なワークフロー - 特定のドメインのためのマルチステップ手順
2. ツール統合 - 特定のファイル形式やAPIで作業するための指示
3. ドメイン専門知識 - 会社固有の知識、スキーマ、ビジネスロジック
4. バンドルされたリソース - 複雑で反復的なタスクのためのスクリプト、リファレンス、アセット

## コア原則

### 簡潔さが鍵

コンテキストウィンドウは公共財です。スキルは、Claudeが必要とする他のすべて（システムプロンプト、会話履歴、他のスキルのメタデータ、実際のユーザーリクエスト）とコンテキストウィンドウを共有します。

**デフォルトの仮定：Claudeは既に非常に賢いです。** Claudeが既に持っていないコンテキストのみを追加します。各情報に挑戦します：「Claudeは本当にこの説明が必要ですか？」「この段落はトークンコストを正当化しますか？」

冗長な説明よりも簡潔な例を優先します。

### 適切な自由度を設定

タスクの脆弱性と変動性に合わせて特異性のレベルを一致させます：

**高い自由度（テキストベースの指示）**: 複数のアプローチが有効な場合、決定がコンテキストに依存する場合、またはヒューリスティックがアプローチを導く場合に使用します。

**中程度の自由度（パラメータ付きの疑似コードまたはスクリプト）**: 優先パターンが存在する場合、いくつかの変動が許容される場合、または設定が動作に影響する場合に使用します。

**低い自由度（特定のスクリプト、少数のパラメータ）**: 操作が脆弱でエラーが発生しやすい場合、一貫性が重要である場合、または特定のシーケンスに従う必要がある場合に使用します。

Claudeがパスを探索することを考えてください：崖のある狭い橋には特定のガードレール（低い自由度）が必要ですが、開けたフィールドでは多くのルートが可能です（高い自由度）。

### スキルの構造

すべてのスキルは、必須のSKILL.mdファイルとオプションのバンドルされたリソースで構成されます：

```
skill-name/
├── SKILL.md (必須)
│   ├── YAMLフロントマターメタデータ (必須)
│   │   ├── name: (必須)
│   │   └── description: (必須)
│   └── Markdown指示 (必須)
└── バンドルされたリソース (オプション)
    ├── scripts/          - 実行可能なコード (Python/Bashなど)
    ├── references/       - 必要に応じてコンテキストに読み込まれるドキュメント
    └── assets/           - 出力で使用されるファイル (テンプレート、アイコン、フォントなど)
```

#### SKILL.md (必須)

すべてのSKILL.mdは以下で構成されます：

- **フロントマター** (YAML): `name`と`description`フィールドを含みます。これらは、Claudeがスキルがいつ使用されるかを判断するために読み取る唯一のフィールドであるため、スキルが何であるか、いつ使用すべきかを明確かつ包括的に説明することが非常に重要です。
- **本文** (Markdown): スキルとそのバンドルされたリソースを使用するための指示とガイダンス。スキルがトリガーされた後にのみ読み込まれます（もし読み込まれる場合）。

#### バンドルされたリソース (オプション)

##### スクリプト (`scripts/`)

決定論的信頼性が必要なタスク、または繰り返し書き直されるタスクのための実行可能なコード（Python/Bashなど）。

- **含めるタイミング**: 同じコードが繰り返し書き直されている場合、または決定論的信頼性が必要な場合
- **例**: PDF回転タスク用の`scripts/rotate_pdf.py`
- **利点**: トークン効率的、決定論的、コンテキストに読み込まずに実行可能
- **注意**: スクリプトは、パッチングや環境固有の調整のためにClaudeによって読み取られる必要がある場合があります

##### リファレンス (`references/`)

Claudeのプロセスと思考に情報を提供するために、必要に応じてコンテキストに読み込まれるドキュメントとリファレンス資料。

- **含めるタイミング**: Claudeが作業中に参照すべきドキュメントの場合
- **例**: 財務スキーマ用の`references/finance.md`、会社NDAテンプレート用の`references/mnda.md`、会社ポリシー用の`references/policies.md`、API仕様用の`references/api_docs.md`
- **ユースケース**: データベーススキーマ、APIドキュメント、ドメイン知識、会社ポリシー、詳細なワークフローガイド
- **利点**: SKILL.mdをリーンに保ち、Claudeが必要と判断した場合にのみ読み込まれます
- **ベストプラクティス**: ファイルが大きい場合（>10k語）、SKILL.mdにgrep検索パターンを含めます
- **重複を避ける**: 情報はSKILL.mdまたはリファレンスファイルのいずれかに存在すべきで、両方ではありません。スキルのコアでない限り、詳細情報にはリファレンスファイルを優先します—これにより、SKILL.mdをリーンに保ちながら、コンテキストウィンドウを占有することなく情報を発見可能にします。SKILL.mdには基本的な手続き的指示とワークフローガイダンスのみを保持し、詳細なリファレンス資料、スキーマ、例をリファレンスファイルに移動します。

##### アセット (`assets/`)

コンテキストに読み込まれるのではなく、Claudeが生成する出力内で使用されるファイル。

- **含めるタイミング**: スキルが最終出力で使用されるファイルを必要とする場合
- **例**: ブランドアセット用の`assets/logo.png`、PowerPointテンプレート用の`assets/slides.pptx`、HTML/Reactボイラープレート用の`assets/frontend-template/`、タイポグラフィ用の`assets/font.ttf`
- **ユースケース**: テンプレート、画像、アイコン、ボイラープレートコード、フォント、コピーまたは変更されるサンプルドキュメント
- **利点**: 出力リソースをドキュメントから分離し、Claudeがコンテキストに読み込まずにファイルを使用できるようにします

#### スキルに含めないもの

スキルには、その機能を直接サポートする必須ファイルのみを含める必要があります。以下のような余分なドキュメントや補助ファイルを作成しないでください：

- README.md
- INSTALLATION_GUIDE.md
- QUICK_REFERENCE.md
- CHANGELOG.md
- など

スキルには、AIエージェントが手元の仕事を行うために必要な情報のみを含める必要があります。それを作成するプロセス、セットアップとテスト手順、ユーザー向けドキュメントなどに関する補助的なコンテキストを含めるべきではありません。追加のドキュメントファイルを作成すると、混乱と混乱を招くだけです。

### 段階的開示デザイン原則

スキルは、コンテキストを効率的に管理するための3レベルの読み込みシステムを使用します：

1. **メタデータ（name + description）** - 常にコンテキスト内（約100語）
2. **SKILL.md本文** - スキルがトリガーされたとき（<5k語）
3. **バンドルされたリソース** - Claudeが必要に応じて（スクリプトはコンテキストウィンドウに読み込まずに実行できるため無制限）

#### 段階的開示パターン

SKILL.md本文を本質的なものに保ち、500行未満にしてコンテキストの肥大化を最小限に抑えます。この制限に近づいたら、コンテンツを別のファイルに分割します。コンテンツを他のファイルに分割する場合、SKILL.mdからそれらを参照し、いつ読み取るかを明確に説明することが非常に重要です。これにより、スキルの読者がそれらが存在し、いつ使用するかを知ることができます。

**重要な原則：** スキルが複数のバリエーション、フレームワーク、またはオプションをサポートする場合、SKILL.mdにはコアワークフローと選択ガイダンスのみを保持します。バリエーション固有の詳細（パターン、例、設定）を別のリファレンスファイルに移動します。

**パターン1：リファレンス付きの高レベルガイド**

```markdown
# PDF処理

## クイックスタート

pdfplumberでテキストを抽出：
[コード例]

## 高度な機能

- **フォーム記入**: 完全なガイドについては[FORMS.md](FORMS.md)を参照
- **APIリファレンス**: すべてのメソッドについては[REFERENCE.md](REFERENCE.md)を参照
- **例**: 一般的なパターンについては[EXAMPLES.md](EXAMPLES.md)を参照
```

Claudeは、必要な場合にのみFORMS.md、REFERENCE.md、またはEXAMPLES.mdを読み込みます。

**パターン2：ドメイン固有の組織**

複数のドメインを持つスキルの場合、無関係なコンテキストを読み込まないように、ドメインごとにコンテンツを整理します：

```
bigquery-skill/
├── SKILL.md (概要とナビゲーション)
└── reference/
    ├── finance.md (収益、請求メトリクス)
    ├── sales.md (機会、パイプライン)
    ├── product.md (API使用、機能)
    └── marketing.md (キャンペーン、帰属)
```

ユーザーが販売メトリクスについて尋ねた場合、Claudeはsales.mdのみを読み取ります。

同様に、複数のフレームワークまたはバリエーションをサポートするスキルの場合、バリエーションごとに整理します：

```
cloud-deploy/
├── SKILL.md (ワークフロー + プロバイダー選択)
└── references/
    ├── aws.md (AWSデプロイメントパターン)
    ├── gcp.md (GCPデプロイメントパターン)
    └── azure.md (Azureデプロイメントパターン)
```

ユーザーがAWSを選択した場合、Claudeはaws.mdのみを読み取ります。

**パターン3：条件付き詳細**

基本コンテンツを表示し、高度なコンテンツにリンク：

```markdown
# DOCX処理

## ドキュメントを作成

新しいドキュメントにはdocx-jsを使用します。[DOCX-JS.md](DOCX-JS.md)を参照してください。

## ドキュメントを編集

簡単な編集の場合、XMLを直接変更します。

**追跡変更の場合**: [REDLINING.md](REDLINING.md)を参照
**OOXML詳細の場合**: [OOXML.md](OOXML.md)を参照
```

Claudeは、ユーザーがそれらの機能を必要とする場合にのみREDLINING.mdまたはOOXML.mdを読み取ります。

**重要なガイドライン：**

- **深くネストされたリファレンスを避ける** - SKILL.mdから1レベル深いリファレンスを保持します。すべてのリファレンスファイルはSKILL.mdから直接リンクする必要があります。
- **長いリファレンスファイルを構造化** - 100行を超えるファイルの場合、Claudeがプレビュー時に完全な範囲を確認できるように、上部に目次を含めます。

## スキル作成プロセス

スキル作成には以下のステップが含まれます：

1. 具体的な例でスキルを理解する
2. 再利用可能なスキルコンテンツを計画する（スクリプト、リファレンス、アセット）
3. スキルを初期化する（init_skill.pyを実行）
4. スキルを編集する（リソースを実装し、SKILL.mdを記述）
5. スキルをパッケージ化する（package_skill.pyを実行）
6. 実際の使用に基づいて反復する

明確な理由がない限り、これらのステップを順番に実行します。

### ステップ1：具体的な例でスキルを理解する

スキルの使用パターンが既に明確に理解されている場合のみ、このステップをスキップします。既存のスキルで作業する場合でも価値があります。

効果的なスキルを作成するには、スキルがどのように使用されるかの具体的な例を明確に理解します。この理解は、直接的なユーザー例またはユーザーフィードバックで検証された生成例のいずれかから得られます。

たとえば、画像エディタースキルを構築する場合、関連する質問には以下が含まれます：

- 「画像エディタースキルはどのような機能をサポートすべきですか？編集、回転、他に何かありますか？」
- 「このスキルがどのように使用されるかの例をいくつか挙げてもらえますか？」
- 「'この画像から赤目を削除する'や'この画像を回転させる'などのリクエストを想像できます。このスキルが使用される他の方法を想像できますか？」
- 「このスキルをトリガーすべきユーザーの発言は何ですか？」

ユーザーを圧倒しないように、1つのメッセージで質問をしすぎないでください。最も重要な質問から始め、より良い効果のために必要に応じてフォローアップします。

スキルがサポートすべき機能について明確な感覚があるときに、このステップを終了します。

### ステップ2：再利用可能なスキルコンテンツを計画する

具体的な例を効果的なスキルに変換するには、各例を以下で分析します：

1. ゼロから例を実行する方法を検討する
2. これらのワークフローを繰り返し実行する際に役立つスクリプト、リファレンス、アセットを識別する

例：「このPDFを回転するのを手伝って」などのクエリを処理する`pdf-editor`スキルを構築する場合、分析は以下を示します：

1. PDFを回転するには、毎回同じコードを書き直す必要があります
2. `scripts/rotate_pdf.py`スクリプトをスキルに保存すると便利です

例：「todoアプリを構築して」や「ステップを追跡するダッシュボードを構築して」などのクエリ用に`frontend-webapp-builder`スキルを設計する場合、分析は以下を示します：

1. フロントエンドWebアプリを書くには、毎回同じボイラープレートHTML/Reactが必要です
2. ボイラープレートHTML/Reactプロジェクトファイルを含む`assets/hello-world/`テンプレートをスキルに保存すると便利です

例：「今日ログインしたユーザーは何人ですか？」などのクエリを処理する`big-query`スキルを構築する場合、分析は以下を示します：

1. BigQueryをクエリするには、毎回テーブルスキーマと関係を再発見する必要があります
2. テーブルスキーマを文書化する`references/schema.md`ファイルをスキルに保存すると便利です

スキルのコンテンツを確立するには、各具体的な例を分析して、含める再利用可能なリソースのリストを作成します：スクリプト、リファレンス、アセット。

### ステップ3：スキルを初期化する

この時点で、実際にスキルを作成する時です。

開発中のスキルが既に存在し、反復またはパッケージ化が必要な場合のみ、このステップをスキップします。この場合、次のステップに進みます。

ゼロから新しいスキルを作成する場合、常に`init_skill.py`スクリプトを実行します。このスクリプトは、スキルに必要なすべてを自動的に含む新しいテンプレートスキルディレクトリを便利に生成し、スキル作成プロセスをはるかに効率的で信頼性の高いものにします。

使用方法：

```bash
scripts/init_skill.py <skill-name> --path <output-directory>
```

スクリプトは：

- 指定されたパスにスキルディレクトリを作成します
- 適切なフロントマターとTODOプレースホルダーを含むSKILL.mdテンプレートを生成します
- サンプルリソースディレクトリを作成します：`scripts/`、`references/`、`assets/`
- カスタマイズまたは削除できる各ディレクトリにサンプルファイルを追加します

初期化後、必要に応じて生成されたSKILL.mdとサンプルファイルをカスタマイズまたは削除します。

### ステップ4：スキルを編集する

（新しく生成されたまたは既存の）スキルを編集する場合、スキルが別のClaudeインスタンスが使用するために作成されていることを覚えておいてください。Claudeにとって有益で非自明な情報を含めます。別のClaudeインスタンスがこれらのタスクをより効果的に実行するのに役立つ手続き的知識、ドメイン固有の詳細、または再利用可能なアセットを検討します。

#### 実証済みのデザインパターンを学習する

スキルのニーズに基づいて、これらの有用なガイドを参照してください：

- **マルチステッププロセス**: 順次ワークフローと条件付きロジックについてはreferences/workflows.mdを参照
- **特定の出力フォーマットまたは品質標準**: テンプレートと例のパターンについてはreferences/output-patterns.mdを参照

これらのファイルには、効果的なスキルデザインのための確立されたベストプラクティスが含まれています。

#### 再利用可能なスキルコンテンツから始める

実装を開始するには、上記で識別された再利用可能なリソースから始めます：`scripts/`、`references/`、`assets/`ファイル。このステップにはユーザー入力が必要な場合があることに注意してください。たとえば、`brand-guidelines`スキルを実装する場合、ユーザーは`assets/`に保存するブランドアセットまたはテンプレート、または`references/`に保存するドキュメントを提供する必要がある場合があります。

追加されたスクリプトは、実際に実行してテストし、バグがなく、出力が期待されるものと一致することを確認する必要があります。類似のスクリプトが多数ある場合、完了までの時間をバランスさせながら、すべてが機能することを確信するために、代表的なサンプルのみをテストする必要があります。

スキルに不要なサンプルファイルとディレクトリは削除する必要があります。初期化スクリプトは構造を示すために`scripts/`、`references/`、`assets/`にサンプルファイルを作成しますが、ほとんどのスキルはそれらすべてを必要としません。

#### SKILL.mdを更新する

**記述ガイドライン：** 常に命令形/不定詞形を使用します。

##### フロントマター

`name`と`description`を含むYAMLフロントマターを記述します：

- `name`: スキル名
- `description`: これはスキルの主要なトリガーメカニズムであり、Claudeがスキルを使用するタイミングを理解するのに役立ちます。
  - スキルが何をするか、および使用するタイミングの特定のトリガー/コンテキストの両方を含めます。
  - すべての「使用するタイミング」情報をここに含めます - 本文には含めません。本文はトリガー後にのみ読み込まれるため、本文の「このスキルを使用するタイミング」セクションはClaudeにとって役に立ちません。
  - `docx`スキルの説明例：「追跡変更、コメント、フォーマット保持、テキスト抽出をサポートする包括的なドキュメント作成、編集、分析。Claudeがプロフェッショナルドキュメント（.docxファイル）で作業する必要がある場合に使用：(1) 新しいドキュメントを作成、(2) コンテンツを変更または編集、(3) 追跡変更で作業、(4) コメントを追加、またはその他のドキュメントタスク」

YAMLフロントマターに他のフィールドを含めないでください。

##### 本文

スキルとそのバンドルされたリソースを使用するための指示を記述します。

### ステップ5：スキルをパッケージ化する

スキルの開発が完了したら、ユーザーと共有される配布可能な.skillファイルにパッケージ化する必要があります。パッケージ化プロセスは、すべての要件を満たしていることを確認するために、最初にスキルを自動的に検証します：

```bash
scripts/package_skill.py <path/to/skill-folder>
```

オプションの出力ディレクトリ指定：

```bash
scripts/package_skill.py <path/to/skill-folder> ./dist
```

パッケージ化スクリプトは：

1. **検証** スキルを自動的に、以下をチェック：

   - YAMLフロントマターフォーマットと必須フィールド
   - スキル命名規則とディレクトリ構造
   - 説明の完全性と品質
   - ファイル組織とリソース参照

2. **パッケージ化** 検証が合格した場合、スキルにちなんで名付けられた.skillファイル（例：`my-skill.skill`）を作成し、すべてのファイルを含み、配布用の適切なディレクトリ構造を維持します。.skillファイルは.skill拡張子付きのzipファイルです。

検証が失敗した場合、スクリプトはエラーを報告し、パッケージを作成せずに終了します。検証エラーを修正し、パッケージ化コマンドを再度実行します。

### ステップ6：反復する

スキルをテストした後、ユーザーは改善を要求する場合があります。多くの場合、これはスキルを使用した直後、スキルがどのように機能したかについての新しいコンテキストで発生します。

**反復ワークフロー：**

1. 実際のタスクでスキルを使用する
2. 苦労や非効率性に気づく
3. SKILL.mdまたはバンドルされたリソースをどのように更新すべきかを識別する
4. 変更を実装し、再度テストする

